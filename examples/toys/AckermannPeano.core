ack m n = case m of Z   -> S n
                    S m -> case n of Z   -> ack m (S Z)
                                     S n -> ack m (ack (S m) n)

root x = ack (S (S Z)) x

-- Optimal output:
--   root x = ackSSZ x
--   ackSSZ n = case n of Z   -> ackSZ (S Z)
--                        S n -> ackSZ (ackSSZ n)
--   ackSZ n = case n of Z   -> ackZ (S Z)
--                       S n -> ackZ (ackSZ n)
--   ackZ n = S n

-- Optimal output with some extra evaluation in ungeneralized branches:
--   root x = ackSSZ x
--   ackSSZ n = case n of Z   -> S (S (S Z))
--                        S n -> ackSZ (ackSSZ n)
--   ackSZ n = case n of Z   -> S (S Z)
--                       S n -> ackZ (ackSZ n)
--   ackZ n = S n

-- Supercompiler trace:
--   <ack (S (S Z)) n>
--   case n of Z   -> <ack (S Z) (S Z)>
--             S n -> <ack (S Z) (ack (S (S Z)) n)>
--   case n of Z   -> <ack Z (ack (S Z) Z)>
--             S n -> <case ack (S (S Z)) n of Z   -> ack Z (S Z)
--                                             S n -> ack Z (ack (S Z) n)>
--   case n of Z   -> S <ack (S Z) Z>
--             S n -> <case (case n of
--                             Z   -> ack (S Z) (S Z)
--                             S n -> ack (S Z) (ack (S (S Z)) n)) of
--                       Z   -> ack Z (S Z)
--                       S n -> ack Z (ack (S Z) n)>
--   case n of Z   -> S <ack Z (S Z)>
--             S n -> case n of
--                      Z   -> <case ack (S Z) (S Z) of
--                                Z   -> ack Z (S Z)
--                                S n -> ack Z (ack (S Z) n)>
--                      S n -> <case ack (S Z) (ack (S (S Z)) n)) of
--                                Z   -> ack Z (S Z)
--                                S n -> ack Z (ack (S Z) n)>
--   case n of Z   -> S (S (S Z))
--             S n -> case n of
--                      Z   -> <case ack Z (ack (S Z) Z) of
--                                Z   -> ack Z (S Z)
--                                S n -> ack Z (ack (S Z) n)>
--                      S n -> <case (case ack (S (S Z)) n) of
--                                      Z   -> ack Z (S Z)
--                                      S n -> ack Z (ack (S Z) n)) of
--                                Z   -> ack Z (S Z)
--                                S n -> ack Z (ack (S Z) n)>
--   case n of Z   -> S (S (S Z))
--             S n -> case n of
--                      Z   -> <ack Z (ack (S Z) (ack (S Z) Z))>
--                      S n -> <case (case ack (S (S Z)) n) of -- Generalise? Two stack frames with same tag ==> whistle blows
--                                      Z   -> ack Z (S Z)
--                                      S n -> ack Z (ack (S Z) n)) of
--                                Z   -> ack Z (S Z)
--                                S n -> ack Z (ack (S Z) n)>


tests = [
    (root Z, S (S (S Z)))
  ]
